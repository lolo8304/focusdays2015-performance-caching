
<!DOCTYPE HTML>
<html>
 
<head>
        <script type="text/javascript" src="canvasjs-1.7.0/canvasjs.min.js"></script>
        <script type="text/javascript" src="jquery-1.11.3/jquery-1.11.3.min.js"></script>


<script type="text/javascript">
	var POP_ITEMS_FROM_DB = 100;
    var MAX_STACK_SIZE = 2*POP_ITEMS_FROM_DB; // number of cached ID's (must be bigger then the number or items we receive from the MongoDB)
    var DATA_LENGTH = 200; // number of dataPoints visible at any point
    var UPDATE_INTERVAL = 1500; // ms to request the new items of the MongoDB


    var stack = []; // queue for Element-ID's

    /** 
      * push the given id to the stack
      * returns true if the ID is pushed, false if it was already in the stack
      */
	function push(id){
		while (stack.length > MAX_STACK_SIZE){
			stack.shift();
		}
	    for (var i = 0; i < stack.length; i++) {
	        if (stack[i] === id) {
	            return false;
	        }
	    }
		stack.push(id);
		return true;		
	}

    var responseTimeQueue = [];
    var taskUpdateView;
    var taskGenerateData;
    var updateChart = function(reset) {};
    var generateUpdateInterval = 1200;

      
      
    // get response times from the MongoDB (filter for cache-stragegy)
    function popLastResponseTimes(callback, n, strategy) {
		$.ajax({
			url: "http://localhost/node/products/"+n+"/strategy/"+strategy,
 		    dataType: 'json',
			type: "GET",
            success:function ( data ) {
		        $.each(data, function(index, element) {
			        if (push(element._id)){
			    		callback(element.time);
				    } else {
					    console.log("item "+element._id+" already in stack, ignore");
					}
		       	});
            }
		});
	}

	// create chart
    window.onload = function () {
        var dps = []; // dataPoints
        var chart = new CanvasJS.Chart("chartContainer",{
            title :{
                text: "Server response time"
            },          
            data: [{
                type: "line",
                dataPoints: dps 
            }]
        });
 
        var xVal = 0;


// FIXME funzt nicht wie es sollte
/* -> ich requeste jede sekunde die letzten100 items
-> reset vom dps (sollte ich nicht machen...)
-> jedes einzelne wird über die callback methode hinzugefügt
-> dann shifte ich um n positionen und rendere erneut...

==> nur die items updaten die noch nicht in der grafik sind
==> in dps nicht nur x und y sondern auch id speichern
==> if (newId isNotIn dps): add to graph
==> if (dps.lenght > maxSize): remove oldest values
ACHTUNG: callback function wird asynchron aufgerufen, muäs alles dort drin erledigt werden...
 */     

 		/**
 		  * callback method to update the chart with on item
 		  */   
        updateChart = function (reset) {
            if (reset) { 
                var count = dps.length;
                while (--count >= 0)  {
                     dps.pop(); 
                }
        }
        popLastResponseTimes( function(yVal) {
            // the callback function is called for each item 
            // ignore response-times below zero, they are invalid
            if (yVal>0){
            	dps.push({
	                 x: xVal,
	                 y: yVal
	            });
                xVal++;
            }
            if (dps.length > DATA_LENGTH ) {
                dps.shift();                
            }
            chart.render();

        }, POP_ITEMS_FROM_DB, "no-cache");

	}; 

	
    // generates first set of dataPoints
    updateChart(DATA_LENGTH); 

    // update chart on a interwal. 
    taskUpdateView = setInterval(function(){updateChart();}, UPDATE_INTERVAL); 


 
    };
    </script>
</head>
<body>
	<h1>focusday 2015</h1>
    <div id="chartContainer" style="height: 300px; width:100%;">
    </div>
    <button id="buttonPause">pause</button>
    <button id="buttonStop">stop</button>
    <button id="buttonStart">start</button>
        <p>Size of queue: <i id="sizeOfResponseQueue"></i></p>
        
    <script>
        $("#buttonPause").on("click", function() {
            if (taskUpdateView) {
                clearTimeout(taskUpdateView);
            }
        });
        $("#buttonStop").on("click", function() {
            if (taskUpdateView) {
                clearTimeout(taskUpdateView);
                taskUpdateView = null;
            }
            if (taskGenerateData) {
                clearTimeout(taskGenerateData);
                taskGenerateData = null;
            }
        });

        $("#buttonStart").on("click", function() {
            // update chart after specified time. 
            var resetData = taskGenerateData == null ? "reset" : null;
            if (taskUpdateView) {
                clearTimeout(taskUpdateView);
            }
            taskUpdateView = setInterval(function(){updateChart(resetData);}, UPDATE_INTERVAL); 
    
            // update chart after specified time. 
            if (taskGenerateData == null) {
                taskGenerateData = setInterval(function(){pushNewResponseTimes("no-cache", 1000, 10); }, generateUpdateInterval); 
            }
        });
        
    </script>
</body>
</html>
 
